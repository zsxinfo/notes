# 2.进程与线程

OS最核心的概念：进程。

## 2.1 进程

- 伪并行：每个进程各运行几十或几百毫秒，CPU快速切换。
- 多处理器系统：2+CPU共享同一个物理内存。

人们很难对多个并行活动进行跟踪，因此，经过多年女里，OS设计者develop一种描述并行的概念模型（顺序进程），使得并行更容易处理。

进程模型

计算机上所有可运行的软件，通常也包括OS，被组织成若干**顺序进程**（sequential process），简称**进程**（process）。CPU在程序间来回切换，被称为**多道程序设计**。

4个事件导致进程的创建：

1. 系统初始化
2. 正在运行的程序执行了创建进程的系统调用
3. 用户请求创建一个新进程
4. 一个批处理作业的初始化

停留在后台处理的进程叫做守护进程（daemon）的查看：
- unix：ps程序
- win：任务管理器

Unix：只有一个系统调用可以用来创建新进程：fork。fork之后，执行execve或者类似的调用。

Win：CreateProcess既处理进程的创建，也负责把正确的程序装入新的进程。该调用有10个参数。

1. 要执行的程序
2. 输入给该程序的命令行参数
3. 各种安全属性
4. 有关打开的文件是否继承的控制位
5. 优先级信息
6. 该进程（若有的话）所需要创建的窗口规格
7. 以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。

可写的内存不可以共享。

进程终止：

1. 正常退出（自愿 exit : ExitProcess
2. 出错退出（自愿
3. 严重错误（非自愿
4. 被其他进程杀死（非自愿 kill : TerminateProcess

进程的三个状态：
a. 运行态
b. 阻塞态
c. 就绪态

运行 --1-->阻塞

运行 --2-->就绪

就绪 --3-->运行

阻塞 --4-->就绪

OS发现进程不能在这样下去，就发生1。或者进程等待读取设备文件，发生1。

进程调度程序引起2和3。进程调度算法：力图在整体效率和进程的公平竞争之间取得平衡。

当进程等待的外部事件发生时，发生转换4。

#### 进程的实现

进程表：process table

进程管理：
- 寄存器
- 程序计数器
- 程序状态字
- 堆栈指针
- 进程状态
- 优先级
- 调度参数
- 进程ID
- 父进程
- 进程组
- 信号
- 进程开始时间
- 使用的CPU时间
- 子进程的CPU时间
- 下次定时器时间

存储管理：
- 正文段指针
- 数据段指针
- 堆栈段指针

文件管理
- 根目录
- 工作目录
- 文件描述符
- 用户ID
- 组ID

中断向量：interrupt vector

中断发生后OS最底层的工作步骤：
1. 硬件压入堆栈程序计数器等。
2. 硬件从中断向量装入新的程序计数器。
3. 汇编语言过程保存寄存器值。
4. 汇编语言过程设置新的堆栈。
5. C中断服务例程运行（典型地读和缓冲输入）
6. 调度程序决定下一个将运行的进程。
7. C过程返回至汇编代码。
8. 汇编语言过程开始运行新的当前进程。

## 2.2 线程 thread

迷你的进程：线程：同一个地址空间中准并行运行多个控制线程的情形。

为什么需要线程？

主要原因：在许多app中，同时发生多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些app分解成可以准并行运行的多个顺序线程，程序设计模型会变得简单。

有了进程模型的抽象，我们不必考虑中断、定时器和上下文切换（交给OS了），而只需要考虑自己的进程。

有了多线程模型的抽象，并行的实体才可以操作同一个地址空间，这是进程模型无法表达的。

第二个原因：线程比进程更轻量级，更快创建，更快撤销。

第三个原因：性能。如果多个线程都是CPU密集计算的，那么不能获得性能增强。如果有大量计算和大量IO处理，拥有多个线程允许这些活动彼此重叠，加快速度。

有限状态机：finite-state machine

三种方法：
- 多线程
- 单线程进程
- 有限状态机：非阻塞系统调用

#### 经典线程模型

轻量级的进程（lightweight process）

线程之间没有保护的，原因：
1. 不可能
2. 没必要

#### POSIX线程

- pthread_create
- pthread_exit
- pthread_join
- pthread_yield
- pthread_attr_init
- pthread_attr_destroy

#### 线程的实现

- 用户态的线程实现
- 内核中的线程实现 
- 混合实现

#### 调度程序激活 scheduler activation 机制

上行调用upcall

// 2022 10 08

## 2.3 进程间通信

Inter Process Communication

### 2.3.1 竞争条件

假脱机目录 spooler directory

多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为**竞争条件**（race condition）。

### 2.3.2 临界区

避免这种错误，关键是要赵楚某种途径来阻止多个进程同时读写共享的数据。换言之，我们需要的是**互斥**（mutual exclusion），即以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。

我们把对共享内存进行访问的程序片段称作**临界区域**（critical region）或**临界区**（critical section）。

一个好的解决方案：
1. 任何两个进程不能同时处于其临界区
2. 不应对CPU的速度和数量做任何假设
3. 临界区外运行的进程不得阻塞其他进程
4. 不得使进程无限期等待进入临界区。

### 2.3.3 忙等待的互斥

1. 屏蔽中断

这个方案不好，把屏蔽中断的权力交给用户进程是不明智的。而且多CPU无效。

2. 锁变量

设一个共享（锁）变量，0初始值，1为临界区。

3. 严格轮换法

连续测试一个变量知道某个值出现为止，称为**忙等待**（busy waiting）。

用于忙等待的锁，称为**自旋锁**（spin lock）。

在一个进程比另一个慢了很多的情况下，轮流进入临界区不是一个好办法。违反条件3.

4. Peterson解法

Peterson的算法 软解决方案 1981年。

5. TSL指令

TSL RX, LOCK ：测试并加锁（test and set lock）

与基于临界区问题的所有解法一样，进程必须在正确的时间调用enter_region和leave_region，解法才能奏效。如果一个进程有欺诈行为，则互斥将会失败。换言之，只有进程合作，临界区才能工作。

一个可替代TSL的指令是XCHG，它原子性地交换了两个位置的内容，例如，一个寄存器与一个存储器字。所有的Intel x86 CPU在底层同步中使用XCHG指令。

### 2.3.4 睡眠与唤醒

Peterson解法和TSL或XCHG解法都是正确的，但它们都有忙等待的缺点。这些解法在本质上是这样的：

当一个进程想进入临界区时，先检查是否允许进入，若不允许，则该进程将原地等待，直到允许为止。

不仅浪费CPU时间，还可能引起预想不到的结果。比如：**优先级反转问题**：进程H优先级由于进程L，但是由于L处于临界区，但是轮不到L调度，所以无法离开临界区，所以H一直在忙等待。

进程间通信原语：它们在无法进入临界区时将被阻塞，而不是忙等待。最简单的是sleep和wakeup。

#### 生产者-消费者问题

### 2.3.5 信号量

信号量 semaphore：取值为0（没有保存下来的唤醒操作）或者正值（表示有一个或多个唤醒操作）

#### 用信号量解决生产-消费者问题

多CPU：每个信号量由一个锁变量进行保护，通过TSL或XCHG指令确保同一时刻只有一个CPU在对信号量进行操作。

三个信号量：
- full: 记录充满的缓冲槽数目，初始为0
- empty：记录空的缓冲槽数目，初始为n
- mutex：确保生产者和消费者不会同时访问缓冲区，初始为1

二元信号量 binary semaphore

互斥是避免混乱所必需的操作。

信号量的另一种用途是用于实现**同步**（synchronization）。

### 2.3.6 互斥量 mutex

0：解锁 其他数值：加锁

1. 快速用户区互斥量futex

等待时间短，自旋锁高效；等待时间长，竞争多，阻塞更有效。

二者结合：futex：快速用户空间互斥

2. pthread中的互斥量

### 2.3.7 管程

死锁：dead lock

管程 monitor

管程和信号量，这些机制都是用于公共内存的互斥问题。

如果分布式系统有多个CPU，每个CPU有自己的私有内存，通过局域网相连，那么这些原语将失效，还需要其他办法。

### 2.3.8 消息传递

message passing 就是其他方案。

send receive

## 2.4 调度

调度程序 scheduler

调度算法 scheduling algorithm

计算密集型 compute-bound

IO密集型 I/O-bound

批处理系统中的调度
1. 先来先服务
2. 最短作业优先
3. 最短剩余时间优先

交互系统中的调度
1. 轮转调度：时间片quantum：通常20~50ms
2. 优先级调度：
3. 多级队列：CTSS：Compatible Time Sharing System
4. 最短进程优先：老化aging
5. 保证调度
6. 彩票调度
7. 公平分享调度

实时系统中的调度

策略和机制

调度机制 scheduling mechanism

调度策略 scheduling policy

### 2.4.6 线程调度

## 2.5 经典IPC问题

哲学家就餐的同步问题 Dijkstra

饥饿 starvation

读者-写者问题

## 2.6 有关进程和线程的研究

## 2.7 小结

// 2022 10 19
































